
fun sizeCheck1(a: List<List<Int>>):Boolean { //Checks if each row of M1 contains the same # of elements 
    for (i in 0..<a.size-1){
        if(a[i].size!=a[i+1].size){
            return false
        }
    }
 	return true    
}

fun sizeCheck2(b: List<List<Int>>):Boolean {//Checks if each row of M2 contains the same # of elements 
    for (i in 0..<b.size-1){
        if(b[i].size!=b[i+1].size){
            return false
        }
    }
 return true    
}
fun rcCheck(a: List<List<Int>>, b: List<List<Int>>):Boolean{// checks if the # of columns of M1 = # of rows in M2
	var cnt: Int=0
    for(i in 0..<a.size){
       if(a[i].size!=b.size){
       	   cnt+=1             
       }   
    }
    if (cnt==a.size){return false}
return true
}
fun matmul( m1: List<List<Int>>, m2: List<List<Int>>):List<Int> {// multiplies M1 and M2 
    val op = mutableListOf<MutableList<Int>>()
	var row =mutableListOf<Int>()
	var temp0= mutableListOf<Int>()
    var sum:Int=0
    var cnt:Int=0

 for (l in 0..<m1.size){// iterates thorugh each row in M1

       for (j in 0..<m2[0].size){// itereates through each column in M2 
           var sum = 0
           for (i in 0..<m1[0].size){//iterates through each element 
               var prod=m1[l][i]*m2[i][j]
               sum+=prod
           }
            for(k in 0..<m1.size){
           		temp0.add(sum)
            }
           row.add(temp0[0])
       	   temp0.clear()
        } 
     }
	return row
} 
 
fun main() {
    //uncomment 2 choices for matrix inputs at a time
    val m1 = listOf(listOf(1,2,3,4),listOf(4,5,6,4),listOf(7,8,9,4))// i/p for M1
    val m2 = listOf(listOf(4,5,6),listOf(1,2,3),listOf(7,8,9),listOf(4,4,4))// i/p for M2
//     val m1 = listOf(listOf(1,2,3),listOf(4,5,6),listOf(7,8,9))
//     val m2 = listOf(listOf(1,2,3),listOf(4,5,6),listOf(9,9,9))
//     val m2 = listOf(listOf(4,5),listOf(1,2),listOf(7,8))
//     val m1 = listOf(listOf(1,2,3,4,5),listOf(0,1,0,1,0),listOf(2,3,4,5,6),listOf(1,0,1,0,1),listOf(5,4,3,2,1))
//     val m2 = listOf(listOf(1,0,2),listOf(0,1,2),listOf(1,0,1),listOf(0,1,1),listOf(1,0,0))
    val en1: Boolean =sizeCheck1(m1)
    val en2: Boolean =sizeCheck2(m2)
    val en3: Boolean =rcCheck(m1,m2)
    val en4: Boolean
    var cnt2: Int=0
    var cnty:Int=0

    
    en4= en1 && en2 && en3	//checks to see if any "error flags" were raised
    if (en1== false){	// error message
       println("ERROR: # of elements in M1 are inconsistant within row(s)\n")
    }
    if (en2== false){	// error message
       println("ERROR: # of elements in M2 are inconsistant within row(s)\n")
    }
    if (en3== false){	// error message
       println("\nERROR: # of Columns of M1 are not equal to # of Rows of M2\n")
      
    }
    println("M1:") 	//prints contents of M1
    for(a in 0..<m1.size){
    	print("\nRow $a: ")
        for(f in 0..<m1[a].size){
            print(m1[a][f]) 
            print(" ")
            if(f<m1[a].size-1){
                print(", ")
            }
        }
    }
    println()
    println("\nM2:")	//prints contents of M1
    for(b in 0..<m2.size){
    	print("\nRow $b: ")
        for(g in 0..<m2[b].size){
            print(m2[b][g]) 
            if(g<m2[b].size-1){
                print(" ")
                print(", ")
            }
        }
    }
       println()
    if (en4== true ){	// if all conditions are met proceed to excecute product of M1 and M2 
       val mulres = matmul(m1,m2)
       println("\nCOMPUTED ANSWER:") 
	   println(mulres)
	   var rowNum: Int=mulres.size/m1.size
        for(c in 0..<mulres.size){
           if(c%rowNum==0){
               println()
               var d: Int=c/rowNum
               print("Row $d: ")
           }
        print(mulres[c])
           if (cnt2<rowNum-1){
           		print(", ")
           }
           cnt2+=1
           if (cnt2==rowNum){
               cnt2=0
           }
       }
        
    }
}
