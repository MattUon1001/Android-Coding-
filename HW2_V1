import kotlin.random.Random

interface GOLBase {
    fun step()
    fun isDead(): Boolean
}

abstract class GOLBaseInt(val width: Int, val height: Int) : GOLBase {
    abstract var board: MutableList<MutableList<Int>>
}

abstract class GOLBaseChar(val width: Int, val height: Int) : GOLBase {
    abstract var board: MutableList<MutableList<Char>>
}

class GOL(width_in: Int, height_in: Int) : GOLBaseInt(width_in, height_in) {
    override var board: MutableList<MutableList<Int>>

    init {
        board = MutableList(height) { MutableList(width) { Random.nextInt(0, 2) } }
    }
    
    override fun step() { 
        for (i in board.indices) { // for every row 
            var cnt: Int
            for (j in board[i].indices) { // for every element 
                cnt = 0
                // corners
                if ((i == 0 && j == 0) ||               // top left
                    (i == 0 && j == board[i].lastIndex) || // top right
                    (i == board.lastIndex && j == 0) ||    // bottom left
                    (i == board.lastIndex && j == board[i].lastIndex)) {
                    // optional: handle corners separately if needed
                } 
                // top and bottom edges (excluding corners)
                else if (i == 0 || i == board.lastIndex) {
                    if (j == 0 || j == board[i].lastIndex) continue
                    if (board[i][j-1] == 1) cnt++ // left neighbor
                    if (board[i][j+1] == 1) cnt++ // right neighbor

                    if (i == 0) { // top row: check bottom neighbors
                        if (board[i+1][j-1] == 1) cnt++
                        if (board[i+1][j]   == 1) cnt++
                        if (board[i+1][j+1] == 1) cnt++
                    }
                    if (i == board.lastIndex) { // bottom row: check top neighbors
                        if (board[i-1][j-1] == 1) cnt++
                        if (board[i-1][j]   == 1) cnt++
                        if (board[i-1][j+1] == 1) cnt++
                    }

                    if (cnt < 2) board[i][j] = 0
                    else if (cnt > 3) board[i][j] = 0
                    else if (board[i][j] == 0 && cnt == 3) board[i][j] = 1
                    else if (cnt == 2 || cnt == 3) board[i][j] = 1
                } 
                // left and right edges (excluding corners)
                else if (j == 0 || j == board[i].lastIndex) {
                    if (board[i+1][j] == 1) cnt++ // bottom neighbor
                    if (board[i-1][j] == 1) cnt++ // top neighbor

                    if (j == 0) { // left edge: check right neighbors
                        if (board[i+1][j+1] == 1) cnt++
                        if (board[i][j+1]   == 1) cnt++
                        if (board[i-1][j+1] == 1) cnt++
                    }
                    if (j == board[i].lastIndex) { // right edge: check left neighbors
                        if (board[i+1][j-1] == 1) cnt++
                        if (board[i][j-1]   == 1) cnt++
                        if (board[i-1][j-1] == 1) cnt++
                    }

                    if (cnt < 2) board[i][j] = 0
                    else if (cnt > 3) board[i][j] = 0
                    else if (board[i][j] == 0 && cnt == 3) board[i][j] = 1
                    else if (cnt == 2 || cnt == 3) board[i][j] = 1
                } 
                // inner cells
                else {
                    //top eighbors
                    if (board[i-1][j-1] == 1) cnt++
                    if (board[i-1][j]   == 1) cnt++
                    if (board[i-1][j+1] == 1) cnt++
                    
                    //left and right neighbors
                    if (board[i][j-1] == 1) cnt++
                    if (board[i][j+1] == 1) cnt++
                    
                    // bottem neighbors
                    if (board[i+1][j-1] == 1) cnt++
                    if (board[i+1][j]   == 1) cnt++
                    if (board[i+1][j+1] == 1) cnt++

                    if (cnt < 2) board[i][j] = 0
                    else if (cnt > 3) board[i][j] = 0
                    else if (board[i][j] == 0 && cnt == 3) board[i][j] = 1
                    else if (cnt == 2 || cnt == 3) board[i][j] = 1
                }
            }
        }
    }

    override fun isDead(): Boolean {
        return board.flatten().all { it == 0 }
    }

    override fun toString(): String {
        return board.map { row ->
            row.map { c ->
                if (c == 0) '.' else '#'
            }.joinToString("")
        }.joinToString("\n")
    }
}

fun main() {
    val g = GOL(5, 5)
    var steps = 0
    while (!g.isDead() && steps < 5) {
        println("Step: $steps")
        println(g)
        println()
        g.step()
        steps += 1
    }
    println(g)
    if (g.isDead()) {
        println("GAME OVER")
    }
}
